# -*- mode: org; coding: utf-8; -*-
# Source:     https://github.com/gregnewman/gmacs
# License:    This file is licensed under the GPL v3.
#+STARTUP: indent

* About
  This is my personal config for Emacs.  It is constructed in literate programming using Org-mode for a documented configuration.

  If you‚Äôre viewing the Org file, you can open source code blocks (those are the ones in begin_src) in a separate buffer by moving your point inside them and
  typing ` C-c ‚Äô ` (org-edit-special). This opens another buffer in emacs-lisp-mode, so you can use M-x eval-buffer to load the changes. If you want to explore how
  functions work, use M-x edebug-defun to set up debugging for that function, and then call it.

* Packages
   Package management using Straight.el combined with use-package for declarative configuration. Straight provides reproducible package installations by managing packages through git, making it easy to clone this config to a new machine and have all packages automatically installed. The configuration includes built-in pseudo-packages to prevent Straight from downloading duplicate versions of packages that come with Emacs (like project, flymake, and xref). Additional settings optimize Straight's performance through shallow git clones, caching autoloads, and checking modifications only on save.
   #+BEGIN_SRC emacs-lisp
     (use-package straight
       :custom
       ;; add project and flymake to the pseudo-packages variable so straight.el doesn't download a separate version than what eglot downloads.
       (straight-built-in-pseudo-packages '(emacs nadvice python image-mode project flymake xref))
       (straight-use-package-by-default t))

     (setq use-package-always-defer t)
     (setq straight-check-for-modifications '(check-on-save find-when-checking))
     (setq straight-vc-git-default-clone-depth 1)
     (setq straight-cache-autoloads t)
   #+END_SRC

* Theme
   Visual theme configuration using Doom Themes, specifically the doom-dracula color scheme for consistency across all contexts. Doom Themes provides carefully crafted color schemes with good contrast and readability. The configuration enables bold and italic fonts for better visual hierarchy, includes a visual bell (flashing mode-line instead of beeping), and improves Org-mode's native fontification. The doom-modeline package provides an informative and aesthetically pleasing mode line showing battery status, time with an analogue clock icon, and other useful information.

   #+BEGIN_SRC emacs-lisp
     (use-package doom-themes
       :demand t
       :config
       ;; Global settings (defaults)
       (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
             doom-themes-enable-italic t) ; if nil, italics is universally disabled

       ;; Enable flashing mode-line on errors
       (doom-themes-visual-bell-config)

       ;; Corrects (and improves) org-mode's native fontification.
       (doom-themes-org-config)
        (load-theme 'doom-dracula t))

     (use-package doom-modeline
       :ensure t
       :init (doom-modeline-mode 1)
       :config
       (setq doom-modeline-battery t)
       ;; Whether display the time. It respects `display-time-mode'.
       (display-time-mode 1)
       (setq doom-modeline-time t)
       ;; Whether to use an analogue clock svg as the live time icon.
       ;; It respects options `doom-modeline-icon', `doom-modeline-time-icon', and `doom-modeline-time-live-icon'.
       (setq doom-modeline-time-analogue-clock t)

       ;; The scaling factor used when drawing the analogue clock.
       (setq doom-modeline-time-clock-size 0.7))
   #+end_src

* Windows Configuration
  Hide things when emacs starts up, namely the tooltips, toolbar and scrollbar.
  Also set `C-z` and `C-x C-z` to nil.  `C-z` minimizes/hides emacs and it's enfuriating when I accidently hit that key combo.

  #+BEGIN_SRC emacs-lisp
    (use-package emacs
      :init
      (menu-bar-mode -1)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)
      (tooltip-mode -1)
      :config
      (setq inhibit-splash-screen t)
      :bind (("C-z" . nil)
             ("C-x C-z" . nil)))
  #+end_src
* Font handling
  Font configuration using Fira Code for both default and fixed-pitch text. Fira Code is a monospace font with programming ligatures that improves code readability. Custom faces are configured for line numbers, mode line, and syntax highlighting to create a consistent and readable editing experience.

#+BEGIN_SRC emacs-lisp
   (custom-set-faces
    ;; Default font for all text
    '(default ((t (:family "Fira Code" :height 130))))
    '(fixed-pitch ((t (:family "Fira Code" :height 110))))

    ;; Current line number
    '(line-number-current-line ((t (:foreground "orange" :inherit line-number))))
    '(mode-line ((t (:family "Fira Code" :weight Bold))))

    ;; Comments italic
    '(font-lock-function-name-face ((t (:family "Fira Code":slant italic))))
    '(font-lock-variable-name-face ((t (:family "Fira Code":weight bold)))))
  #+END_SRC

* One liners preferences
  Fundamental Emacs settings that configure basic editor behavior, file handling, display preferences, and system integration. These settings don't warrant individual sections but are essential for daily use. Grouped by function for easier navigation and maintenance.

  #+BEGIN_SRC emacs-lisp
    ;; Personal information
    (setq user-full-name "Greg Newman"
          user-mail-address "greg@gregnewman.org")

    ;; Editor defaults
    (setq-default indent-tabs-mode nil)  ; Use spaces, not tabs
    (setq ring-bell-function (lambda ()))  ; Disable audible bell
    (setq confirm-kill-emacs 'yes-or-no-p)  ; Prevent accidental exits
    (setq require-final-newline t)  ; POSIX compliance
    (setq-default line-spacing 0.15)  ; Slightly more readable line spacing
    (setq explicit-shell-file-name "/bin/zsh")  ; Use zsh for shell commands

    ;; Backup file configuration - centralized location with version control
    (setq backup-directory-alist `(("." . "~/.saves")))
    (setq backup-by-copying t)  ; Don't clobber symlinks
    (setq delete-old-versions t)  ; Clean up old backups automatically
    (setq kept-new-versions 10)
    (setq kept-old-versions 10)
    (setq version-control t)  ; Use version numbers for backups

    ;; Display settings
    (global-display-line-numbers-mode)
    (setq-default display-fill-column-indicator-column 88)  ; Python line length (Black/ruff)
    (show-paren-mode 1)  ; Highlight matching parentheses
    (global-hl-line-mode 1)  ; Highlight current line
    (set-face-background 'hl-line "#1C1B1A")  ; Subtle highlight color

    ;; Language-specific indentation
    (setq js-indent-level 2)  ; JavaScript/TypeScript standard

    ;; Desktop mode - save/restore sessions across restarts
    (desktop-save-mode 1)
    (setq desktop-dirname "~/.emacs.d/desktops/")
    (setq desktop-base-file-name (concat ".desktop." (system-name)))  ; Per-machine sessions
    (setq desktop-path (list desktop-dirname))
    (setq desktop-base-lock-name "lock")
    (setq desktop-load-locked-desktop t)

    ;; Auto-revert mode - keep buffers in sync with disk changes (useful for git/Dropbox)
    (global-auto-revert-mode 1)
    (setq auto-revert-use-notify nil)  ; Use polling instead of filesystem events
    (setq auto-revert-interval 5)  ; Check every 5 seconds

    ;; TAGS configuration
    (setq tags-table-list (list "~/.emacs.d/TAGS"))

    ;; Isearch improvements - show match count during search
    (setq isearch-lazy-count t)
    (setq lazy-count-prefix-format nil)
    (setq lazy-count-suffix-format "   (%s/%s)")

    ;; Modern defaults
    (setq sentence-end-double-space nil)  ; Single space after sentences
    (setq delete-selection-mode t)  ; Typing deletes selection
    (setq dired-auto-revert-buffer t)  ; Keep dired buffers fresh

    ;; File associations
    (add-to-list 'auto-mode-alist '("\\.astro\\'" . js-ts-mode))

    ;; Location for calendar/sunrise-sunset calculations
    (setq calendar-latitude 35.064905)
    (setq calendar-longitude -80.769724)
    (setq calendar-location-name "Charlotte, NC")
   #+end_src

* Transparency
  Frame transparency control for visual customization. By default, frames are set to 100% opaque. The gn/transparency function (bound to C-c t) allows interactive adjustment of frame transparency from 0 (fully transparent) to 100 (fully opaque), useful for seeing underlying windows or creating aesthetic effects when working with multiple applications.

#+BEGIN_SRC emacs-lisp
  ;; set default to 100% opaque
  (set-frame-parameter (selected-frame) 'alpha '(100 100))
  (add-to-list 'default-frame-alist '(alpha 100 100))

  ;; convenience function to toggle transparency given a value
  (defun gn/transparency (value)
     "Sets the transparency of the frame window. 0=transparent/100=opaque"
     (interactive "nTransparency Value 0 - 100 opaque:")
     (set-frame-parameter (selected-frame) 'alpha value))

  (global-set-key (kbd "C-c t") 'gn/transparency)
#+END_SRC

* Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist
             '("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode))
    )

#+END_SRC

* Icons, Git Gutter and Recent files
  Visual enhancements and file access utilities. All-the-icons provides icon fonts used throughout the UI by packages like doom-modeline and all-the-icons-completion. Git-gutter displays visual indicators in the fringe showing added, modified, and deleted lines compared to the git repository, with keybindings for navigating between changes (C-x n/p) and reverting hunks (C-x v r). Recentf mode maintains a list of recently opened files (up to 200, showing 15 in menus), making it easy to quickly reopen files you've worked on recently.

   #+BEGIN_SRC emacs-lisp
     ;; icons
     (use-package all-the-icons)

     ;; ;; Git Gutter
     (use-package git-gutter
       :defer 1
       :diminish git-gutter-mode
       :config (global-git-gutter-mode)
       :init
       (progn
         (setq git-gutter:separator-sign " "
               git-gutter:lighter " GG"))
       :config
       (progn 
         (set-face-foreground 'git-gutter:deleted "#990A1B")
         (set-face-foreground 'git-gutter:modified "#00736F")
         (set-face-foreground 'git-gutter:added "#546E00"))
       :bind (("C-x p" . git-gutter:previous-hunk)
              ("C-x n" . git-gutter:next-hunk)
              ("C-x v =" . git-gutter:popup-hunk)
              ("C-x v r" . git-gutter:revert-hunk)))

     ;; Recent files
     (setq recentf-save-file (concat user-emacs-directory "recentf")
           recentf-max-saved-items 200
           recentf-max-menu-items 15)
     (recentf-mode t)
   #+end_src

* Saveplace
  Remembers cursor position in files across Emacs sessions. When reopening a file, the cursor automatically returns to where you were last editing, saving time and maintaining context. This is particularly useful for long files or when working on multiple files across different sessions.

   #+BEGIN_SRC emacs-lisp
     (save-place-mode +1)
     (setq-default save-place t)
   #+end_src

* Custom function to move to beginning of line and move lines up and down
     Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

   #+BEGIN_SRC emacs-lisp
     (defun my/smarter-move-beginning-of-line (arg)
       "Move point back to indentation of beginning of line.

        Move point to the first non-whitespace character on this line.
        If point is already there, move to the beginning of the line.
        Effectively toggle between the first non-whitespace character and
        the beginning of the line.

        If ARG is not nil or 1, move forward ARG - 1 lines first.  If
        point reaches the beginning or end of the buffer, stop there."
       (interactive "^p")
       (setq arg (or arg 1))

       ;; Move lines first
       (when (/= arg 1)
         (let ((line-move-visual nil))
           (forward-line (1- arg))))

       (let ((orig-point (point)))
         (back-to-indentation)
         (when (= orig-point (point))
           (move-beginning-of-line 1))))

       ;; remap C-a to `smarter-move-beginning-of-line'
       (global-set-key [remap move-beginning-of-line]
                       'my/smarter-move-beginning-of-line)

     (defun gn/move-line-up ()
       "Move the current line up."
       (interactive)
       (transpose-lines 1)
       (forward-line -2)
       (indent-according-to-mode))

     (defun gn/move-line-down ()
       "Move the current line down."
       (interactive)
       (forward-line 1)
       (transpose-lines 1)
       (forward-line -1)
       (indent-according-to-mode))

     (global-set-key [(meta shift up)]  'gn/move-line-up)
     (global-set-key [(meta shift down)]  'gn/move-line-down)
   #+end_src

* OmniFocus
  Quick capture integration with OmniFocus task manager via URL scheme. The gn/omnifocus-capture function (bound to C-c o) creates tasks in OmniFocus with optional notes, due dates (using org-read-date for familiar date input), and location information from the current file and line number. This enables capturing tasks from within Emacs while maintaining context about where the task originated, creating a seamless bridge between coding and task management workflows.

#+BEGIN_SRC emacs-lisp
  (defun gn/omnifocus-capture ()
    "Capture a task with optional note, due date, and location to OmniFocus via URL scheme"
    (interactive)
    (let* ((task-name (read-string "Task name: "))
           (task-note (read-string "Note (optional): "))
           ;; Use org-read-date with empty default - just press Enter to skip
           (due-date (org-read-date nil nil nil "Due date (Enter to skip): " nil nil t))
           (due-date-param (if (or (not due-date) (string-empty-p due-date))
                              "" 
                            (concat "&due=" (url-hexify-string due-date))))
           ;; Ask about location only if in a file
           (capture-location (and (buffer-file-name)
                                 (string= "y" (read-string "Include current location? (y/N): " "n"))))
           (location-info (when capture-location
                           (format "File: %s, Line: %d" 
                                  (file-name-nondirectory (buffer-file-name))
                                  (line-number-at-pos))))
           (full-note (if location-info
                         (if (string-empty-p task-note)
                             location-info
                           (concat task-note "\n\nLocation: " location-info))
                       task-note))
           (encoded-name (url-hexify-string task-name))
           (encoded-note (if (string-empty-p full-note) 
                            "" 
                          (concat "&note=" (url-hexify-string full-note))))
           (omnifocus-url (concat "omnifocus:///add?name=" encoded-name encoded-note due-date-param "&autosave=true")))
      (call-process "open" nil nil nil omnifocus-url)
      (message "Task sent to OmniFocus: %s%s%s" 
               task-name 
               (if (string-empty-p due-date) "" (concat " (due: " due-date ")"))
               (if location-info " [with location]" ""))))
    
    (defun gn/omnifocus-capture-original ()
      "Capture a task with optional note to OmniFocus via URL scheme"
      (interactive)
      (let* ((task-name (read-string "Task name: "))
             (task-note (read-string "Note (optional): "))
             (encoded-name (url-hexify-string task-name))
             (encoded-note (if (string-empty-p task-note) 
                               "" 
                             (concat "&note=" (url-hexify-string task-note))))
             (omnifocus-url (concat "omnifocus:///add?name=" encoded-name encoded-note "&autosave=true")))
        (call-process "open" nil nil nil omnifocus-url)
        (message "Task sent to OmniFocus: %s" task-name)))

    ;; Bind it directly to a key
    (global-set-key (kbd "C-c o") 'gn/omnifocus-capture)
#+END_SRC

* Which-key
  I forget bindings for modes I don't use regularly. Which-key provides nice reminders.

  #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :defer 0.5
      :init
      (which-key-mode)
      :config
      (which-key-setup-side-window-right-bottom)
      (setq which-key-sort-order 'which-key-key-order-alpha
        which-key-side-window-max-width 0.33
        which-key-idle-delay 0.5)
      :diminish which-key-mode)

    (provide 'init-which-key)
  #+end_src

* iBuffer
  I use ibuffer a lot for switching between buffers from a list of available open buffers.
  These settings help to organize that list.

   #+Begin_SRC emacs-lisp
     (global-set-key (kbd "C-x C-b") 'ibuffer)
     (autoload 'ibuffer "ibuffer" "List buffers." t)

     (setq ibuffer-saved-filter-groups
           (quote (("default"
                    ("Python"
                     (mode . python-ts-mode))
                    ("HTML"
                     (mode . mhtml-mode))
                    ("JS"
                     (or (mode . js-ts-mode)
                         (filename . ".js")))
                    ("TXT"
                     (mode . text-mode))
                    ("YAML"
                     (filename . "yaml"))
                    ("Org" ;; all org-related buffers
                     (mode . org-mode))
                    ("Lisp"
                     (mode . emacs-lisp-mode))))))

     ;; don't show empty groups
     (setq ibuffer-show-empty-filter-groups nil)

     (add-hook 'ibuffer-mode-hook
               (lambda ()
                 (ibuffer-switch-to-saved-filter-groups "default")))

     ;; Add full path to buffer title
     (setq frame-title-format
           (list (format "%s %%S: %%j " (system-name))
                 '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))
   #+end_src

* Hydra
  Create sticky keybinding menus for related commands. Hydra allows grouping multiple related commands under a single prefix key, keeping the binding active until you explicitly quit. The hydra-zoom example (F2) provides easy text scaling: press F2, then repeatedly press 'g' to zoom in or 'l' to zoom out without re-pressing F2. This makes repetitive operations much more fluid. Hydras are useful for any set of commands you use in succession, like window management, git operations, or navigation.

   #+BEGIN_SRC  emacs-lisp
     (use-package hydra)

     (defhydra hydra-zoom (global-map "<f2>")
       "zoom"
       ("g" text-scale-increase "in")
       ("l" text-scale-decrease "out"))
   #+end_src

* System packages
  Automatic system binary verification for package dependencies. The :ensure-system-package keyword allows packages to declare required system binaries (like ripgrep, git, etc.) and automatically check or install them. Currently disabled as system packages are managed manually via Homebrew or other package managers. Kept in configuration for potential future use if automatic system package management becomes desirable.

#+BEGIN_SRC emacs-lisp
  ;; (use-package use-package-ensure-system-package
  ;; :straight (use-package-ensure-system-package
  ;;            :type git
  ;;            :host github
  ;;            :repo "jwiegley/use-package"
  ;;            :files ("use-package-ensure-system-package.el")))
#+end_src
* Justfiles
  Syntax highlighting and editing support for Justfiles. Just is a command runner similar to make but with a simpler syntax. This mode provides proper fontification and indentation for Justfile recipes, making it easier to write and maintain build commands and task runners in modern projects.

#+BEGIN_SRC emacs-lisp
  (use-package just-mode
    :ensure t)
#+END_SRC

* Org-mode
  [[https://gettingthingsdone.com/][Getting Things Done]] (GTD), is a grouping of productivity processes following five basic principles.
  
  * Capture - Everything in your mind needs to be captured because your mind is "a horrible office".  This is typically the inbox.org file in my setup but is also done in analog notebooks, email and voice memos.
  * Clarify - Every task that doesn't take two minutes to do should be broken down into actionable tasks that simplify the larger scope of the project.
  * Organize - All projects and next actions are organized into areas, assigned due dates if needed, prioritized and effort estimates added to them.  If the tasks/projects are not something to do right now they are still organized for later consumption.  Anything that needs to be on the calendar should be added but keep the calendar sacred.  Calendars should only be for appointments or hard-carved blocks of time.
  * Reviews - Reviews should be handled on a regular basis.  I do a daily review of what should be the priorities for the day but I also do weekly and monthly reviews to keep my systems from getting stale and/or stuck.
  * Engage - Choose the next action and get to work.

    I have gitwatch running on my machine which watches my org directory and commits changes as they come in.
    #+BEGIN_EXAMPLE bash
    gitwatch -r origin -b main . &
    #+END_EXAMPLE
** Fontification and Beautification
   Visual improvements for Org documents to create a more pleasant reading and editing experience. Emphasis markers (like *bold* and /italic/) are hidden to reduce visual noise, and visual-line-mode along with variable-pitch-mode make prose more readable. The configuration includes commented-out custom face settings for further typography customization if desired. Use C-u C-x = to inspect faces and customize appearance.

#+BEGIN_SRC emacs-lisp
    ;; Load org-faces to make sure we can set appropriate faces
    (require 'org-faces)

    ;; Hide emphasis markers on formatted text
    (setq org-hide-emphasis-markers t)
    ;; When Visual Line mode is enabled, `word-wrap' is turned on in this buffer, and simple editing commands are redefined to act on visual lines, not logical lines. 
    (add-hook 'org-mode-hook 'visual-line-mode)
    (add-hook 'org-mode-hook 'variable-pitch-mode)

    ;; Resize Org headings
    ;; (dolist (face '((org-level-1 . 1.0)
    ;;                 (org-level-2 . 1.0)
    ;;                 (org-level-3 . 1.0)
    ;;                 (org-level-4 . 1.0)
    ;;                 (org-level-5 . 1.0)
    ;;                 (org-level-6 . 1.0)
    ;;                 (org-level-7 . 1.0)
    ;;                 (org-level-8 . 1.0))))
  ;;    (set-face-attribute (car face) nil :font "JetBrains Mono" :weight 'medium :height (cdr face)))

    ;; Make the document title a bit bigger
    ;;(set-face-attribute 'org-document-title nil :font "JetBrains Mono" :weight 'bold :height 1.1)

    ;; Make sure certain org faces use the fixed-pit;; ch face when variable-pitch-mode is on
  ;;   (custom-theme-set-faces
  ;;    'user
  ;; ;;   '(variable-pitch ((t (:family "Monaspace Neon" :height 120 :weight thin))))
  ;; ;;   '(fixed-pitch ((t ( :family "Fira Code" :height 115))))
  ;;    '(org-block ((t (:inherit fixed-pitch))))
  ;;    '(org-code ((t (:inherit (shadow fixed-pitch)))))
  ;;    '(org-formula ((t (:inherit fixed-pitch))))
  ;;    '(org-checkbox ((t (:inherit fixed-pitch))))
  ;;    '(org-document-info ((t (:foreground "dark orange"))))
  ;;    '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
  ;;    '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
  ;;    '(org-link ((t (:foreground "cyan" :underline t :weight light))))
  ;;    '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  ;;    '(org-property-value ((t (:inherit fixed-pitch))) t)
  ;;    '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
  ;;    '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
  ;;    '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.9))))
  ;;    '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))
#+END_SRC
** Configuration
   Core Org-mode settings optimized for performance and GTD workflow. The configuration uses deferred loading to prevent slow startup times - expensive operations like recursively finding agenda files only run when Org actually loads. Settings control agenda behavior (7-day span starting Monday), task dependencies (enforcing TODO relationships), refile targets (up to 5 levels deep in agenda files), and various display preferences. The org-protocol module enables capturing from external applications. Keybindings for store-link (C-c l), agenda (C-c a), and capture (C-c c) are globally accessible.

#+BEGIN_SRC emacs-lisp
  ;; Lightweight settings - safe to run immediately
  (setq org-modules '(org-protocol))

  (setq org-src-fontify-natively t)

  ;; DEFER ALL expensive org operations until org actually loads
  (with-eval-after-load 'org
    (org-load-modules-maybe t)
    
    ;; This is EXPENSIVE - only calculate when org loads, not at startup!
    (setq org-agenda-files 
          (directory-files-recursively "~/Dropbox/Org/" "\\.org$"))
    
    ;; All other org settings
    (setq org-agenda-window-setup 'current-window
          org-agenda-start-on-weekday 1
          org-agenda-tags-column -102
          org-agenda-span 7
          org-tags-column 88
          org-agenda-sticky nil
          org-agenda-inhibit-startup t
          org-agenda-use-tag-inheritance t
          org-agenda-show-log t
          org-agenda-skip-scheduled-if-done t
          org-agenda-skip-deadline-if-done t
          org-use-speed-commands t
          org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled
          org-columns-default-format "%14SCHEDULED %Effort{:} %CLOCKSUM_T{:} %1PRIORITY %TODO %50ITEM %TAGS"
          org-enforce-todo-dependencies t
          org-enforce-todo-checkbox-dependencies t
          org-fontify-done-headline t
          org-startup-folded t
          org-refile-targets '((org-agenda-files :maxlevel . 5))
          org-refile-allow-creating-parent-nodes 'confirm)
    
    ;; Load markdown export only when org loads
    (require 'ox-md))

  ;; Keybindings - these are cheap, keep outside
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)

  ;; Hooks - these are lazy, keep outside
  (add-hook 'org-mode-hook (lambda () (setq truncate-lines nil)))
  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'org-indent-mode)
  (add-hook 'org-mode-hook #'gn/orgmode-ignore-line-numbers-mode)

  ;; Remove duplicate hook - this was already added above
  ;; (add-hook 'org-mode-hook 'visual-line-mode)  <-- DELETE if you see this duplicated
#+END_SRC
** Alerts
   Desktop notifications for Org agenda items. Org-alert monitors upcoming deadlines and scheduled items, sending macOS notifications when tasks are approaching their due time. Configured to check every 60 seconds and notify 5 minutes before events, with a 2-minute window after events start. Notifications fade after 2 minutes to avoid cluttering the desktop.

#+BEGIN_SRC emacs-lisp
  (use-package org-alert
    :ensure t 
    :config 
        (setq org-alert-interval 60 
              org-alert-notify-cutoff 5
              org-alert-notify-after-event-cutoff 2) 
        (org-alert-enable))

  (use-package alert 
    :config
    (setq alert-default-style 'osx-notifier
          alert-fade-time 120))
#+END_SRC
** Todo Keywords
   Custom TODO keywords aligned with GTD workflow. Two sequences are defined: active task states (TODO ‚Üí NEXT ‚Üí DONE/PROJECTDONE) and deferred states (WAITING/SOMEDAY ‚Üí CANCELLED). The @ symbol in keywords like "WAITING(w@/!)" triggers a note prompt when entering that state, creating an audit trail for why tasks are waiting or cancelled. Color-coding provides visual distinction: active states in bright colors (green/cyan), waiting states in red/magenta, and completed states in gray. All tasks automatically timestamp when marked DONE.

   #+BEGIN_SRC emacs-lisp
     ;; Keywords
     (setq org-todo-keywords
       (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)" "PROJECTDONE(e)")
               (sequence "WAITING(w@/!)" "SOMEDAY(s@/!)" "|" "CANCELLED(c@/!)"))))

     ;; Anytime a task is marked done the line states `CLOSED: [timestamp]
     (setq org-log-done 'time)

     (setq org-todo-keyword-faces
       (quote (("TODO" :foreground "lime green" :weight bold)
               ("NEXT" :foreground "cyan" :weight bold)
               ("DONE" :foreground "dim gray" :weight bold)
               ("PROJECTDONE" :foreground "dim gray" :weight bold)
               ("WAITING" :foreground "tomato" :weight bold)
               ("SOMEDAY" :foreground "magenta" :weight bold)
               ("CANCELLED" :foreground "dim gray" :weight bold))))
   #+end_src

** Capture mode keybinding
   I use C-c c to start capture mode
   #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-c c") 'org-capture)
   #+end_src
** Capture templates
    Capture template are critical for keeping focused on the current work and not getting sent down the proverbial rabbit hole.  It's also handy for knowledge investements while working.  For instance, a method in a python library I need to understand more deeply, I can trigger the capture template for Knowledge Investments with `C=c c k`, add some context and with `C=c C=c` close and save the capture without leaving my position in the file.  The link to where I found the method is captured in the template and I can visit that later in the day when I have time to dive deep.

    For my reference the syntax is as follows
    #+BEGIN_EXAMPLE
    ("t" "Todo" entry (file "~/Dropbox/Org/inbox.org")
                 "* TODO %?\n%U\n%a\n" :clock-keep t)
    #+end_example

    `t` is the trigger key for Todo.
    Todo entry is layman's term for the capture followed by what file to store it in.
    The instruction regex starts with the tag or keyword then [[https://orgmode.org/manual/Template-expansion.html#Template-expansion][template expansions]].
       - %? Position the cursor where I was
       - %u, %U Inactive timestamp
       - %a annotation, normally the link created with org-store-link
       - :clock-keep keeps the clock running if I'm clocking a task

   #+BEGIN_SRC emacs-lisp
     ;; Capture templates
     (setq org-indent-indentation-per-level 2)
     (setq org-capture-templates
         (quote (("t" "Todo" entry (file "~/Dropbox/Org/inbox.org")
                 "* TODO %?\n%U\n%a\n" :clock-keep t)
                 ("k" "Knowledge Investment" entry (file "~/Dropbox/Org/inbox.org")
                  "* %? :KI:\n%U\n%a\n" :clock-keep t)
                 ("n" "Note" entry (file "~/Dropbox/Org/inbox.org")
                  "* %? :NOTE:\n%U\n%a\n" :clock-keep t)
                 ("d" "Daybook" entry (file+olp+datetree "~/Dropbox/Org/daybook.org")
                  "* %?" :clock-keep t)
                 ("o" "OBTF" entry (file+olp+datetree "~/Dropbox/Org/OBTF.org")
                  "* %<%H:%M> %?" :jump-to-captured t)
                 ("m" "Meeting" entry (file "~/Dropbox/Org/inbox.org")
                  "* Meeting with %? :MEETING:\n%U" :clock-keep t)
                 ("p" "Phone call" entry (file "~/Dropbox/Org/inbox.org")
                  "* PHONE %? :PHONE:\n%U" :clock-keep t))))
   #+end_src

** Org Babel
   Org Babel enables executable code blocks within Org documents for literate programming and reproducible research. Configured to support multiple languages including Python, JavaScript, Emacs Lisp, SQL, and Ditaa for diagrams. Code evaluation is enabled without confirmation prompts for a smoother workflow. This allows mixing documentation with executable code, making it ideal for literate configurations, data analysis notebooks, and technical documentation.

#+BEGIN_SRC emacs-lisp
  ;; Load babel only when org loads
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((python . t)
       (js . t)
       (emacs-lisp . t)
       (org . t)
       (sql . t)
       (ditaa . t)))
    
    ;; Don't prompt before running code in org
    (setq org-confirm-babel-evaluate nil))
#+END_SRC

** Agenda commands
   Custom agenda views tailored for GTD workflow. These commands provide different perspectives on tasks: a simple agenda view (c) showing high-priority items first, a comprehensive due-date grouped view (d) organizing all tasks by when they're due, and focused views (f., fh) for daily planning and hotlist management. The custom commands use helper functions to filter by priority and organize tasks into meaningful groups. Org-super-agenda provides additional grouping capabilities by category for a comprehensive task overview.

   #+BEGIN_SRC emacs-lisp
     (defun gn/org-skip-subtree-if-priority (priority)
     "Skip an agenda subtree if it has a priority of PRIORITY.

     PRIORITY may be one of the characters ?A, ?B, or ?C."
       (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
        (if (= pri-value pri-current)
          subtree-end
        nil)))

     (defun gn/org-agenda-with-tip (arg)
       (org-agenda-list arg)
       (let ((inhibit-read-only t)
          (pos (point)))
       (goto-char (point-max))
       (goto-char pos)))

     ;; Reset everything to nil
     (setq org-agenda-custom-commands nil)

     (add-to-list 'org-agenda-custom-commands
               '("b" "Agenda" gn/org-agenda-with-tip))

         ;; Taken from doc.norang.ca/org-mode.html
     (add-to-list 'org-agenda-custom-commands
          '("c" "Simple agenda view"
               ((agenda "")
               (tags "PRIORITY=\"A\""
                 ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                  (org-agenda-overriding-header "HIGH PRIORITY ITEMS")))
               (alltodo ""
                 ((org-agenda-skip-function
                  '(or (gn/org-skip-subtree-if-priority ?A)
                   (org-agenda-skip-if nil '(scheduled deadline)))))))))

     (add-to-list 'org-agenda-custom-commands
               '("f" . "FOCUS...") t)

     (add-to-list 'org-agenda-custom-commands
               '("d" "All Tasks (grouped by Due Date)"
                 ((tags-todo "DEADLINE<\"<+0d>\""
                             ((org-agenda-overriding-header "OVERDUE")
                              (org-agenda-skip-function
                               '(org-agenda-skip-entry-if 'notdeadline))))
                  (tags-todo "DEADLINE=\"<+0d>\""
                             ((org-agenda-overriding-header "DUE TODAY")
                              (org-agenda-skip-function
                               '(org-agenda-skip-entry-if 'notdeadline))))
                  (tags-todo "DEADLINE=\"<+1d>\""
                             ((org-agenda-overriding-header "DUE TOMORROW")
                              (org-agenda-skip-function
                               '(org-agenda-skip-entry-if 'notdeadline))))
                  (tags-todo "DEADLINE>\"<+1d>\"+DEADLINE<=\"<+7d>\""
                             ((org-agenda-overriding-header "DUE WITHIN A WEEK")
                              (org-agenda-skip-function
                               '(org-agenda-skip-entry-if 'notdeadline))))
                  (tags-todo "DEADLINE>\"<+7d>\"+DEADLINE<=\"<+28d>\""
                             ((org-agenda-overriding-header "DUE WITHIN A MONTH")
                              (org-agenda-skip-function
                               '(org-agenda-skip-entry-if 'notdeadline))))
                  (tags-todo "DEADLINE>\"<+28d>\""
                             ((org-agenda-overriding-header "DUE LATER")
                              (org-agenda-skip-function
                               '(org-agenda-skip-entry-if 'notdeadline))))
                  (tags-todo "TODO={WAIT}"
                             ((org-agenda-overriding-header "WAITING FOR")
                              (org-agenda-skip-function
                               '(org-agenda-skip-entry-if 'deadline))))
                  (todo ""
                        ((org-agenda-overriding-header "UNSCHEDULED")
                         (org-agenda-skip-function
                          '(org-agenda-skip-entry-if 'deadline)))))
                 ((org-agenda-sorting-strategy '(priority-down))
                  (org-agenda-write-buffer-name "All Tasks (grouped by Due Date)"))
                 "~/Dropbox/Org/all-tasks-by-due-date.pdf") t)

     (add-to-list 'org-agenda-custom-commands
               `("f." "Today"
                 ((agenda ""
                          ((org-agenda-entry-types '(:timestamp :sexp))
                           (org-agenda-overriding-header
                            (concat "CALENDAR Today: "
                                    (format-time-string "%a %d" (current-time))))
                           (org-agenda-span 'day)))
                  (tags-todo "DEADLINE=\"<+0d>\""
                             ((org-agenda-overriding-header "DUE TODAY")
                              (org-agenda-skip-function
                               '(org-agenda-skip-entry-if 'notedeadline))
                              (org-agenda-sorting-strategy '(priority-down))))
                  (tags-todo "DEADLINE<\"<+0d>\""
                             ((org-agenda-overriding-header "OVERDUE")
                              (org-qagenda-skip-function
                               '(org-agenda-skip-entry-if 'notedeadline))
                              (org-agenda-sorting-strategy '(priority-down))))
                  (agenda ""
                          ((org-agenda-entry-types '(:scheduled))
                           (org-agenda-overriding-header "SCHEDULED")
                           (org-agenda-skip-function
                            '(org-agenda-skip-entry-if 'todo 'done))
                           (org-agenda-sorting-strategy
                            '(priority-down time-down))
                           (org-agenda-span 'day)
                           (org-agenda-start-on-weekday nil)
                           (org-agenda-time-grid nil)))
                  (todo "DONE"
                        ((org-agenda-overriding-header "COMPLETED"))))
                 ((org-agenda-format-date "")
                  (org-agenda-start-with-clockreport-mode nil))) t)

     (add-to-list 'org-agenda-custom-commands
               '("fh" "Hotlist"
                 ((tags-todo "DEADLINE<\"<+0d>\""
                             ((org-agenda-overriding-header "OVERDUE")))
                  (tags-todo "DEADLINE>=\"<+0d>\"+DEADLINE<=\"<+1w>\""
                             ((org-agenda-overriding-header "DUE IN NEXT 7 DAYS")))
                  (tags-todo "DEADLINE=\"\"+FLAGGED|DEADLINE>\"<+1w>\"+FLAGGED"
                             ((org-agenda-overriding-header "FLAGGED"))))
                 ((org-agenda-todo-ignore-scheduled 'future)))  t)

   #+end_src

   Org-Super-Agenda commands

   #+BEGIN_SRC emacs-lisp
     (use-package org-super-agenda
       :straight
       (org-super-agenda
        :type git
        :host github
        :repo "alphapapa/org-super-agenda")
       :config
       (org-super-agenda-mode t)
       (add-to-list 'org-agenda-custom-commands
                    '("gt" "All Tasks - Grouped"
                      ((todo "" ((org-super-agenda-groups
                                  '((:name "All Tasks" :auto-category t)))))))))
   #+end_src

** Org bullets and misc settings
   Visual enhancements for Org documents using org-bullets to replace plain asterisks with attractive Unicode bullets. Leading stars are hidden and indentation is managed by org-indent-mode for a cleaner outline appearance. Additional fontification settings improve the display of headings, quotes, verse blocks, and completed headlines. Org-download enables easy image insertion with drag-and-drop, storing images in a central directory. Org-fancy-priorities replaces A/B/C priority indicators with emoji for visual appeal.

 #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :commands org-bullets-mode
       :init
       (add-hook 'org-mode-hook 'org-bullets-mode))
       (progn
        (require 'org-indent)
        (org-indent-mode t))
     (setq org-hide-leading-stars t)
     (setq org-fontify-whole-heading-line t)
     (setq org-fontify-quote-and-verse-blocks t)
     (setq org-fontify-done-headline t)

     (use-package org-download)
     (setq-default org-download-image-dir "~/Dropbox/Org/img")

     (use-package org-fancy-priorities
       :ensure t
       :hook
       (org-mode . org-fancy-priorities-mode)
       :config
       (setq org-fancy-priorities-list '("üÖ∞Ô∏è" "üÖ±Ô∏è" "1Ô∏è‚É£" "‚òï")))

   #+end_src
* Denote
[[https://protesilaos.com/emacs/denote][Denote]] for taking notes and [[https://github.com/mclear-tools/consult-notes][consult-notes]] for quickly searching

#+BEGIN_SRC emacs-lisp
  (use-package denote
    :custom
    ((denote-directory "~/Dropbox/Org/denote/")
     (denote-prompts '(title keywords))
     ;; Use orgmode format by default
     (denote-file-type 'org)
     (denote-date-prompt-use-org-read-date t))
    :hook
    (dired-mode . denote-dired-mode))

  (use-package consult-notes
    :commands (consult-notes
               consult-notes-search-in-all-notes
               ;; if using org-roam 
               consult-notes-org-roam-find-node
               consult-notes-org-roam-find-node-relation)
    :config
    (setq consult-notes-file-dir-sources '(("Org"  ?o  "~/Dropbox/Org/")
                                           ("Denote" ?d "~/Dropbox/Org/denote/")))

    (consult-notes-org-headings-mode)
    (consult-notes-denote-mode)
    ;; search only for text files in denote dir
    (setq consult-notes-denote-files-function (lambda () (denote-directory-files nil t t))))
 #+END_SRC
* Path from shell
When starting emacs gui on Mac OS, the paths are not read from .zshrc
Using `exec-path-from-shell` fixes this.

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :demand t
       :config
       (when (memq window-system '(mac ns x))
         (exec-path-from-shell-initialize)))
   #+end_src
* Pyenv
  Python version management using pyenv integration. This configuration automatically activates the correct Python virtual environment based on .python-version files in project directories. The pyenv-mode-auto package handles automatic switching, while custom functions (pyenv-activate-current-project and pyenv-init) ensure proper initialization and project-specific version activation. On Emacs startup, the global pyenv version is set as the default. When opening Python files, if a .python-version file exists in the project root, that specific Python version is activated automatically. The Python mode also enables the fill-column indicator at 88 characters for Black/ruff compatibility.

   #+BEGIN_SRC emacs-lisp
      (use-package pyenv-mode-auto
        :demand t)

      (defun pyenv-activate-current-project ()
        "Automatically activates pyenv version if .python-version file exists."
        (interactive)
        (let ((python-version-directory (locate-dominating-file (buffer-file-name) ".python-version")))
        (if python-version-directory
           (let* ((pyenv-version-path (f-expand ".python-version" python-version-directory))
                  (pyenv-current-version (s-trim (f-read-text pyenv-version-path 'utf-8))))
             (pyenv-mode-set pyenv-current-version)
             (message (concat "Setting virtualenv to " pyenv-current-version))))))

      (defvar pyenv-current-version nil nil)

      (defun pyenv-init()
      "Initialize pyenv's current version to the global one."
      (let ((global-pyenv (replace-regexp-in-string "\n" "" (shell-command-to-string "pyenv global"))))
       (message (concat "Setting pyenv version to " global-pyenv))
       (pyenv-mode-set global-pyenv)
       (setq pyenv-current-version global-pyenv)))

      (add-hook 'after-init-hook 'pyenv-init)

      (use-package pyenv-mode
        :config
        (with-eval-after-load 'pyenv-mode
          (define-key pyenv-mode-map (kbd "C-c C-s") nil)))

        (add-hook 'python-ts-mode-hook #'display-fill-column-indicator-mode)
   #+end_src
* Projectile and RG (Ripgrep)
  Project management and fast code searching tools. Projectile provides project-aware commands for navigating files, switching between projects, running tests, and more. All projectile commands are available under the C-c p prefix. The rg package integrates ripgrep (a faster alternative to grep) with Emacs, offering powerful regex search capabilities across project files with better performance than traditional grep. Together, these tools make it easy to work with large codebases by understanding project boundaries and providing fast search across entire projects.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :bind-keymap
       ("C-c p" . projectile-command-map))

     (use-package rg
       :ensure-system-package rg)
   #+end_src
   
* Eglot, Eldoc and Tree-sitter
  This section configures the Language Server Protocol (LSP) stack for modern IDE-like features in programming modes. The stack consists of tree-sitter for fast, accurate syntax parsing, Eglot as the LSP client providing code intelligence, and supporting tools for documentation display, error checking, and automatic formatting. This setup replaces heavier alternatives like LSP-mode with a lighter, faster, built-in approach that integrates seamlessly with Emacs 29+.

** Tree-sitter Configuration
   Tree-sitter provides fast, incremental syntax parsing using proper grammar files for significantly better highlighting, indentation, and code understanding compared to traditional regexp-based modes. The treesit-auto package automatically installs and activates tree-sitter grammars for supported languages, with graceful fallback to traditional modes if tree-sitter is unavailable. Maximum syntax highlighting level (4) is enabled for the best visual distinction of code elements.

#+BEGIN_SRC emacs-lisp
  ;; Tree-sitter configuration
  (use-package treesit-auto
    :straight (:host github :repo "renzmann/treesit-auto")
    :config
    (setq treesit-auto-install 'prompt)
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode)
    ;; Enhanced syntax highlighting
    (setq treesit-font-lock-level 4)
    (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+END_SRC

** Major Mode Remapping
   Automatically activates tree-sitter modes when available instead of traditional modes. This mapping ensures that opening Python, JavaScript, TypeScript, YAML, and other supported files will use the faster, more accurate tree-sitter parsers by default. The remapping is transparent - no changes needed to file associations or hooks.

#+BEGIN_SRC emacs-lisp
  (setq major-mode-remap-alist
        '((yaml-mode . yaml-ts-mode)
          (bash-mode . bash-ts-mode)
          (js-mode . js-ts-mode)
          (js2-mode . js-ts-mode)
          (js-base-mode . js-ts-mode)
          (typescript-mode . typescript-ts-mode)
          (json-mode . json-ts-mode)
          (css-mode . css-ts-mode)
          (python-mode . python-ts-mode)
          (tsx-mode . tsx-ts-mode)
          (jsx-mode . tsx-ts-mode)))
#+END_SRC

** Python LSP Server Selection
   Dual language server setup supporting both basedpyright and Ty (Astral's new Rust-based type checker). Toggle between servers by changing =my/python-lsp-server= and reloading, or use =M-x my/switch-python-lsp= to toggle and reconnect interactively. Ty offers significantly faster incremental type checking (10-80x faster than basedpyright) with better diagnostics, but is currently in Beta. Basedpyright remains the stable fallback option.

#+BEGIN_SRC emacs-lisp
  ;; Python LSP Server Selection
  (defvar my/python-lsp-server 'ty
    "Which Python language server to use: 'basedpyright or 'ty")

  (defun my/python-lsp-command ()
    "Return the LSP command based on selected server."
    (pcase my/python-lsp-server
      ('ty '("ty" "server"))
      ('basedpyright '("basedpyright-langserver" "--stdio"
                       :initializationOptions (:basedpyright (:plugins (
                         :ruff (:enabled t
                               :lineLength 88
                               :exclude ["E501"]
                               :select ["E" "F" "I" "UP"])
                         :pycodestyle (:enabled nil)
                         :pyflakes (:enabled nil)
                         :pylint (:enabled nil)
                         :rope_completion (:enabled t)
                         :autopep8 (:enabled nil))))))))

  (defun my/switch-python-lsp ()
    "Toggle between Ty and basedpyright, restart Eglot."
    (interactive)
    (setq my/python-lsp-server
          (if (eq my/python-lsp-server 'ty) 'basedpyright 'ty))
    (when (eglot-managed-p)
      (ignore-errors (eglot-shutdown (eglot-current-server)))
      (sleep-for 0.5)  ; Give it a moment to shut down
      (eglot-ensure))
    (message "Switched to %s" my/python-lsp-server))
#+END_SRC

** Eglot LSP Configuration
   Eglot is the built-in LSP client (as of Emacs 29) providing IDE-like features including code completion, documentation, go-to-definition, refactoring, and more. Configured for optimal performance with deferred loading and minimal event logging. Language servers are configured per-mode: dynamically selected Python server (basedpyright or Ty), and typescript-language-server for JavaScript/TypeScript. The Python configuration integrates ruff for fast linting while keeping type checking disabled for performance. Keybindings use the C-c l prefix for all LSP actions. Python mode includes additional setup for proper indentation, code folding, and line length (88 chars for Black/ruff compatibility).

#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :ensure t
    :defer t  ; Add this
    :commands (eglot eglot-ensure)  ; Add this
    :custom
    ;; Optimize performance
    (eglot-send-changes-idle-time 0.5)
    (eglot-extend-to-xref t)
    (eglot-events-buffer-size 0)  ; Add this for better performance
    :config
    ;; Move eglot-server-programs to :config block
    (setq eglot-server-programs
          '((python-ts-mode . (lambda (&rest _) (my/python-lsp-command)))
            ((js-ts-mode typescript-ts-mode tsx-ts-mode) .
             ("typescript-language-server" "--stdio"))))
    (setq-default
     eglot-workspace-configuration
     '(:basedpyright (
       :typeCheckingMode "off"
     )
     :basedpyright.analysis (
       :diagnosticSeverityOverrides (
         :reportUnusedCallResult "none"
       )
       :inlayHints (
         :callArgumentNames :json-false
       )
     )))
    :bind (:map eglot-mode-map
                ("C-c l a" . eglot-code-actions)
                ("C-c l r" . eglot-rename)
                ("C-c l f" . eglot-format)
                ("C-c l d" . eldoc)
                ("C-c l o" . eglot-code-action-organize-imports)
                ("C-c l h" . eglot-inlay-hints-mode)
                ("C-c l q" . eglot-shutdown-all))
    :hook ((python-ts-mode . eglot-ensure)
           (js-ts-mode . eglot-ensure)
           (typescript-ts-mode . eglot-ensure)
           (tsx-ts-mode . eglot-ensure)
           ;; Python-specific #+setupfile: things
           (python-ts-mode . (lambda ()
                               (setq-local indent-tabs-mode nil
                                           tab-width 4
                                           python-indent-offset 4)
                               (superword-mode 1)
                               (hs-minor-mode 1)
                               (set-fill-column 88)
                               (display-line-numbers-mode 1)))))
#+END_SRC

** Flycheck Integration
   Flycheck provides additional on-the-fly syntax checking beyond what LSP offers, giving immediate feedback on code errors as you type. Configured to use ruff for Python linting, which provides extremely fast linting for common Python errors and style violations.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :hook (python-ts-mode . flycheck-mode)
    :config
    (setq flycheck-python-ruff-executable "ruff"))
#+END_SRC

** Eldoc Documentation
   Eldoc displays function signatures, variable documentation, and other contextual information in the echo area or a dedicated buffer as you code. Configured to prefer the documentation buffer for longer content and to compose documentation from multiple sources (LSP, built-in help, etc.) for comprehensive information display.

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :init
    (global-eldoc-mode)
    :custom
    (eldoc-echo-area-use-multiline-p nil)
    (eldoc-echo-area-prefer-doc-buffer t)
    (eldoc-documentation-strategy 'eldoc-documentation-compose))
#+END_SRC

** Format-all Integration
   Automatic code formatting on save for consistent code style across projects. Format-all auto-detects the appropriate formatter for each language (ruff for Python, prettier for JavaScript/TypeScript, etc.) and applies formatting according to project configuration files. Bound to C-c f for manual formatting when needed.

#+BEGIN_SRC emacs-lisp
  (use-package format-all
    :bind ("C-c f" . format-all-buffer)
    :hook ((python-ts-mode . format-all-mode)
           (js-ts-mode . format-all-mode)
           (typescript-ts-mode . format-all-mode)))
#+END_SRC

* Vertico, Marginalia, Savehist, Orderless, Embark, Embark Consult
  Modern completion framework stack replacing older systems like Helm and Ivy. This modular approach combines several focused packages that work together: Vertico provides the vertical completion UI, Orderless enables flexible matching, Marginalia adds rich annotations, Savehist persists history across sessions, and Embark provides context-aware actions on completion candidates. Consult extensions integrate this framework with project management and navigation tools. This setup provides fast, powerful completion for commands, files, buffers, and more.

** Vertico - Completion UI
   Vertico provides a fast, minimalist vertical completion interface in the minibuffer. Configured to show 13 candidates at a time with dynamic resizing. Unlike Helm or Ivy, Vertico focuses purely on the UI and delegates matching and annotation to other packages, making it lightweight and fast.

#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :defer 0.1
     :custom
     (vertico-count 13)                    ; Number of candidates to display
     (vertico-resize t)
     (vertico-cycle nil) ; Go from last to first candidate and first to last (cycle)?
     :init
     (vertico-mode))
#+END_SRC

** Savehist - History Persistence
   Saves minibuffer history across Emacs sessions, making frequently-used commands, file paths, and search terms readily available. This creates a better completion experience by learning from your usage patterns over time.

#+BEGIN_SRC emacs-lisp
   (use-package savehist
     :defer 0.1
     :init
     (savehist-mode))
#+END_SRC

** Orderless - Matching Strategy
   Flexible, space-separated matching that allows finding candidates by typing parts of the name in any order. For example, "buf py" matches "python-buffer.py". This is far more intuitive than traditional prefix matching and dramatically speeds up navigation. File completion uses partial-completion for path segments while other completions use orderless.

#+BEGIN_SRC emacs-lisp
   (use-package orderless
     :init
     ;; Configure a custom style dispatcher (see the Consult wiki)
     ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
     ;;       orderless-component-separator #'orderless-escapable-split-on-space)
     (setq completion-styles '(orderless basic)
           completion-category-defaults nil
           completion-category-overrides '((file (styles partial-completion)))))
#+END_SRC

** Marginalia - Rich Annotations
   Adds helpful annotations to completion candidates showing file permissions, buffer modes, command keybindings, and other contextual information. These annotations appear in the right margin of the completion list, making it easier to identify the correct candidate. M-A cycles through different annotation levels.

#+BEGIN_SRC emacs-lisp
   (use-package marginalia
     :defer 0.1
     ;; Either bind `marginalia-cycle' globally or only in the minibuffer
     :bind (("M-A" . marginalia-cycle)
            :map minibuffer-local-map
            ("M-A" . marginalia-cycle))

     :custom
     (marginalia-max-relative-age 0)
     (marginalia-align 'right)

     :init
     (marginalia-mode))
#+END_SRC

** Consult Extensions
   Consult-based extensions for improved navigation and project integration. Consult-imenu provides enhanced Python symbol navigation (methods, classes, variables). Consult-projectile integrates project management with the completion framework. Consult-dir makes directory navigation easier by suggesting recent directories, bookmarks, and project roots.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'consult-imenu
    (dolist (python '(python-mode python-ts-mode))
      (add-to-list 'consult-imenu-config
                 `(,python
                   :toplevel "Method"
                   :types ((?f "Field" font-lock-variable-name-face)
                           (?c "Class" font-lock-property-use-face)
                           (?m "Method" font-lock-function-name-face)
                           (?M "Module" font-lock-builtin-face)
                           (?v "Variable" font-lock-variable-name-face))))))

  (use-package consult-projectile
    :straight (consult-projectile :type git :host gitlab :repo "OlMon/consult-projectile" :branch "master")
    :commands (consult-projectile)
    :bind (("C-x 4 p" . consult-projectile-find-file-other-window)))
           ;;("M-s r" . consult-ripgrep)
           ;;("M-s f" . projectile-ripgrep)))

  (use-package consult-dir
    ;; This package helps ease traveling across directories by providing directory
    ;; candidates related to current buffers, bookmarks, and projects.  Further,
    ;; like other ~consult.el~ functions, you can use narrowing keys.  See
    ;; https://github.com/karthink/consult-dir.
    :after (consult)
    :bind (("C-x C-d" . consult-dir)
           :map minibuffer-local-completion-map
           ("C-x C-d" . consult-dir)
           ("C-x C-j" . consult-dir-jump-file)))
#+END_SRC

** Embark - Context Actions
   Provides context-aware actions on completion targets and other objects. Press C-. on a completion candidate to see available actions (e.g., on a file: open, rename, delete; on a command: execute, describe, where-is). Embark-dwim (C-;) performs the most likely action automatically. This creates a powerful "act-on-thing-at-point" interface throughout Emacs. Embark-consult integration provides preview capabilities in Embark collect buffers.

#+BEGIN_SRC emacs-lisp
   (use-package embark
     :ensure t
     :bind
     (("C-." . embark-act)         ;; pick some comfortable binding
      ("C-;" . embark-dwim)        ;; good alternative: M-.
      ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

     :init

     ;; Optionally replace the key help with a completing-read interface
     (setq prefix-help-command #'embark-prefix-help-command)

     ;; Show the Embark target at point via Eldoc. You may adjust the
     ;; Eldoc strategy, if you want to see the documentation from
     ;; multiple providers. Beware that using this can be a little
     ;; jarring since the message shown in the minibuffer can be more
     ;; than one line, causing the modeline to move up and down:

     ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
     ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

     :config

     ;; Hide the mode line of the Embark live/completions buffers
     (add-to-list 'display-buffer-alist
                  '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                    nil
                    (window-parameters (mode-line-format . none)))))
#+END_SRC

** Visual Enhancements
   Embark-consult provides preview integration so completion candidates can be previewed in Embark collect buffers. All-the-icons-completion adds file type icons to completion candidates in the marginalia annotations, making it easier to visually distinguish files, directories, and different file types at a glance.

#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :ensure t ; only need to install it, embark loads it after consult if found
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

   (use-package all-the-icons-completion
     :after (marginalia all-the-icons)
     :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
     :init
     (all-the-icons-completion-mode))
#+end_src

* Cape and Corfu
  In-buffer completion framework providing IDE-like autocomplete popups as you type. Cape (Completion At Point Extensions) supplies completion backends for various sources like files, keywords, dabbrev (dynamic abbreviations), and more. Corfu provides the sleek popup UI that displays completion candidates directly at point. Together they create a fast, unobtrusive completion experience that works alongside LSP completion from Eglot. This complements the minibuffer completion framework (Vertico) by handling in-buffer completions.

** Cape - Completion Backends
   Cape provides multiple completion sources (backends) that can suggest completions from different contexts: dabbrev for words from open buffers, file for file paths, keyword for programming language keywords, and more. These backends are globally available and can be manually triggered with C-c h prefix. Cape intelligently combines results from multiple sources for comprehensive suggestions.

#+BEGIN_SRC emacs-lisp
    (use-package cape
      :init
      (add-to-list 'completion-at-point-functions #'cape-dabbrev)
      (add-to-list 'completion-at-point-functions #'cape-file)
      (add-to-list 'completion-at-point-functions #'cape-keyword)
      :bind (("C-c h d" . cape-dabbrev)
             ("C-c h e" . cape-elisp-block)
             ("C-c h f" . cape-file)
             ("C-c h h" . cape-history)
             ;; ("C-c h s" . cape-symbol)
             ("C-c h w" . cape-dict)))
#+END_SRC

** Corfu - Completion UI
   Corfu displays completion candidates in a small popup window at point (where you're typing) rather than in the minibuffer. Configured for automatic completion with cycling through candidates. Enabled globally but especially useful in prog-mode, shell-mode, and eshell-mode. The popup is fast, lightweight, and stays out of the way while providing immediate feedback as you type.

#+BEGIN_SRC emacs-lisp
    (use-package corfu
      :custom
      (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
      (corfu-auto t)                 ;; Enable auto completion
      ;; (corfu-separator ?\s)          ;; Orderless field separator
      ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
      ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
      ;; (corfu-preview-current nil)    ;; Disable current candidate preview
      ;; (corfu-preselect 'prompt)      ;; Preselect the prompt
      ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
      ;; (corfu-scroll-margin 5)        ;; Use scroll margin

      ;; Enable Corfu only for certain modes.
      :hook ((prog-mode . corfu-mode)
             (shell-mode . corfu-mode)
             (eshell-mode . corfu-mode))

      ;; Recommended: Enable Corfu globally.  This is recommended since Dabbrev can
      ;; be used globally (M-/).  See also the customization variable
      ;; `global-corfu-modes' to exclude certain modes.
      :init
      (global-corfu-mode))
#+END_SRC

** Integration Settings
   General Emacs completion settings that integrate Cape and Corfu with the rest of the completion system. TAB is configured to handle both indentation and completion intelligently (tab-always-indent 'complete), trying completion when indentation doesn't make sense. Ispell completion is disabled in favor of cape-dict. The command completion predicate hides mode-specific commands that don't apply to the current buffer, reducing noise in M-x completion.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    ;; TAB cycle if there are only few candidates
    ;; (setq completion-cycle-threshold 3)

    ;; Enable indentation+completion using the TAB key.
    ;; `completion-at-point' is often bound to M-TAB.
    (setq tab-always-indent 'complete)

    ;; Emacs 30 and newer: Disable Ispell completion function. As an alternative,
    ;; try `cape-dict'.
    (setq text-mode-ispell-word-completion nil)

    ;; Emacs 28 and newer: Hide commands in M-x which do not apply to the current
    ;; mode.  Corfu commands are hidden, since they are not used via M-x. This
    ;; setting is useful beyond Corfu.
    (setq read-extended-command-predicate #'command-completion-default-include-p))

#+END_SRC

* Magit
  Magit is a powerful Git interface for Emacs, providing a comprehensive porcelain for version control operations. Access the status buffer with C-x g to stage, commit, push, pull, branch, merge, rebase, and more through an intuitive keyboard-driven interface. The configuration integrates hl-todo to highlight TODO/FIXME/HACK keywords in code with color coding, and magit-todos to display these keywords directly in the Magit status buffer, making it easy to track TODOs across the project during git workflows. This creates a seamless workflow for tracking both code changes and outstanding tasks.

  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :bind ("C-x g" . magit-status)
      :custom
      (magit-git-executable "/opt/homebrew/bin/git"))

    (use-package hl-todo
      :config
      ;; Adding a new keyword: TEST.
      (add-to-list 'hl-todo-keyword-faces '("TODO" . "red"))
      (add-to-list 'hl-todo-keyword-faces '("FIXME" . "orange"))
      (add-to-list 'hl-todo-keyword-faces '("HACK" . "gold"))
      :init
      (add-hook 'python-ts-mode-hook (lambda () (hl-todo-mode t)))
      )

    (use-package magit-todos
      :after magit
      :after hl-todo
      :config
      (setq magit-todos-depth 2)
      (setq magit-todos-exclude-globs '("*.js.map"))
      (magit-todos-mode))
   #+end_src

* Docker
  Docker container and image management directly from Emacs. Provides an interface (C-c d) for listing, managing, inspecting, and controlling Docker containers, images, networks, and volumes without leaving the editor. Particularly useful for development workflows that involve containers, allowing you to start/stop services, view logs, and inspect container state alongside your code. See https://github.com/Silex/docker.el for full documentation.

#+BEGIN_SRC emacs-lisp
  (use-package docker
    :ensure t
    :bind ("C-c d" . docker))
#+end_src
* Winner Mode
  Window configuration undo/redo system. Winner mode records window layout changes, allowing you to undo (C-c left) or redo (C-c right) window configuration changes. Extremely useful when you accidentally close a window, split incorrectly, or want to return to a previous layout. The configuration excludes boring buffers like *Completions* and *Help* from being restored, keeping the history focused on meaningful layouts.

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure t
    :commands (winner-undo winner-redo)
    :custom
    (winner-boring-buffers '("*Completions*" "*Help*" "*Apropos*" "*Buffer List*" "*info*" "*Compile-Log*")))
  (winner-mode 1)
#+END_SRC

* Avy
Avy makes searching and selecting so much easier. `M-s` is my keybinding, type a string and choose the selection in buffer.
#+BEGIN_SRC emacs-lisp
      (use-package avy
        :ensure t
        :config
        (avy-setup-default)
        :bind ("M-s" . avy-goto-char-timer))
#+end_src
* Rainbow Mode
  Visual feedback for color codes by displaying the actual color as the background. When editing CSS, Emacs Lisp, web-mode, or Python files, hex color codes (#ff0000) and RGB values are highlighted with their actual color, making it immediately clear what color the code represents. This eliminates the need to preview colors separately and speeds up color-related editing.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :hook (emacs-lisp-mode web-mode python-ts-mode))
#+END_SRC
* Yasnippet
  Template expansion system for reducing repetitive typing. Yasnippet allows you to type abbreviations that expand into code templates with tab stops for filling in variables. For example, typing "def" and expanding might create a full function definition with placeholders for the function name, parameters, and body. Yasnippet-snippets provides a large collection of pre-made snippets for many languages, and you can create custom snippets for your own patterns.

#+BEGIN_SRC emacs-lisp
    (use-package yasnippet)
    (use-package yasnippet-snippets)
    (yas-global-mode 1)
#+END_SRC
* Indent bars
Trying out some nicer looking indent bars [[https://github.com/jdtsmith/indent-bars/tree/main][from jdtsmith/indent-bars]]
#+BEGIN_SRC emacs-lisp
    (use-package indent-bars
      :custom
      (indent-bars-treesit-support t)
      (indent-bars-no-descend-string t)
       (indent-bars-treesit-ignore-blank-lines-types '("module"))
       (indent-bars-treesit-wrap '((python argument_list parameters ; for python, as an example
           			              list list_comprehension
           			              dictionary dictionary_comprehension
           			              parenthesized_expression subscript)))
      :config
      (setq
       indent-bars-color '(highlight :face-bg t :blend 0.2)
       indent-bars-prefer-character 1
       indent-bars-pattern ".*.*.*.*"
       indent-bars-width-frac 0.5
       indent-bars-pad-frac 0.2
       indent-bars-zigzag 0.1
       indent-bars-color-by-depth '(:palette ("red" "green" "orange" "cyan") :blend 1)
       indent-bars-highlight-current-depth '(:blend 0.5))
      :hook
      ((python-base-mode yaml-mode js-base-mode web-mode) . indent-bars-mode))
#+END_SRC

* Mac Link
  Integration for grabbing links from macOS applications into Org-mode. The org-mac-grab-link function (C-c g in org-mode) can pull links and metadata from Safari, Chrome, Mail, and other Mac applications, creating properly formatted org-mode links. This is particularly useful for capturing web references, emails, or other resources into your Org notes while maintaining context about where information came from.

#+BEGIN_SRC emacs-lisp
  ;; Org-mac-link is being pulled from Jeremy's fork. I was getting errors with the main repo.
  (use-package org-mac-link
    ;; Similar to `grab-mac-link' but a bit specific to `org-mode'.
    :straight (org-mac-link :type git :host github :repo "jeremyf/org-mac-link")
    :bind (:map org-mode-map (("C-c g" . org-mac-grab-link))))
#+end_src

* Golden Ratio
  Automatic window resizing based on the golden ratio for optimal visual balance. When enabled, the active window is automatically resized to take up a larger proportion of the frame following the golden ratio (approximately 1.618:1), making it easier to focus on the current task while keeping other windows visible but smaller. Currently disabled (mode 0) but available to enable if desired for automatic window management.

#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :ensure t
    :diminish golden-ratio-mode
    :init
    (golden-ratio-mode 0))
#+END_SRC
* Logos (writing) and Olivetti
  Distraction-free writing modes for focused prose editing. Logos provides commands for narrowing focus to page-like sections (treating org headings or form feeds as pages), while Olivetti creates a centered, narrow text column similar to writeroom or zen modes. Together they transform Emacs into a minimal writing environment, ideal for drafting documents, writing long-form content, or editing prose without programming-related distractions. Useful for working with Org documents, Markdown, or any text-heavy files.

#+BEGIN_SRC emacs-lisp
  (use-package logos
    :ensure t
    :config
    (setq logos-outlines-are-pages t)
    )

  (use-package olivetti
    :ensure t)
#+END_SRC
* Nov Mode for epub
  EPUB e-book reader built into Emacs. Nov mode allows reading EPUB files directly within Emacs, providing a comfortable reading experience with proper text rendering, navigation between chapters, and integration with Emacs features like bookmarks and search. Useful for reading technical books, documentation, or any EPUB content without leaving your editor. Files with .epub extension automatically open in nov-mode.

#+BEGIN_SRC emacs-lisp
  (use-package nov
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+END_SRC

* Emojis
  Emoji display and rendering support across Emacs. Emojify mode converts emoji shortcodes (:smile:, :rocket:, etc.) and Unicode emoji into actual graphical emojis, making text more expressive and visually engaging. Particularly useful for Org-mode documents, Markdown files, commit messages, and any text where emoji add clarity or personality. Enabled globally after initialization.

#+BEGIN_SRC emacs-lisp
  (use-package emojify
    :hook (after-init . global-emojify-mode))
#+END_SRC
* Activities
Activities, this Emacs library allows the user to manage frames/tabs, windows, and buffers according to their purpose. An ‚Äúactivity‚Äù comprises a frame or tab, its window configuration, and the buffers displayed in them‚Äìits ‚Äústate‚Äù; this state would be related to a certain task the user performs at various times, such as developing a certain software project, reading and writing email, working with one‚Äôs Org mode system, etc.

[[https://github.com/alphapapa/activities.el][alphapapa/activities.el: Activities for Emacs (suspend and resume activities, i.e. frames/tabs and their windows, buffers)]]

#+BEGIN_SRC emacs-lisp
  (use-package activities
    :init
    (activities-mode)
    ;; (activities-tabs-mode) ;; if you want tabs
    ;; Prevent `edebug' default bindings from interfering.
    (setq edebug-inhibit-emacs-lisp-mode-bindings t)

    :bind
    (("C-x C-a C-n" . activities-new)
     ("C-x C-a C-d" . activities-define)
     ("C-x C-a C-a" . activities-resume)
     ("C-x C-a C-s" . activities-suspend)
     ("C-x C-a C-k" . activities-kill)
     ("C-x C-a RET" . activities-switch)
     ("C-x C-a b" . activities-switch-buffer)
     ("C-x C-a g" . activities-revert)
     ("C-x C-a l" . activities-list)))
#+END_SRC
* Bookmarks
  Persistent bookmarks for quick navigation to frequently accessed files and locations. Unlike recent files, bookmarks persist across sessions and can mark specific positions within files, not just file paths. Set bookmarks with C-x r m, jump to them with C-x r b, and view all bookmarks with C-x r l. The configuration enables automatic saving, visual indicators in the fringe, and confirmation before deletion. Particularly useful for marking key files in large projects or important locations in long documents. See http://emacswiki.org/emacs/BookMarks for more information.

| Keystroke           | Action                  |
|---------------------+-------------------------|
| C-x r m             | Set a bookmark          |
| C-x r b             | Jump to a bookmark      |
| C-x r l             | List your bookmarks     |
| M-x bookmark-delete | Delete bookmark by name |

#+BEGIN_SRC emacs-lisp
  (setq bookmark-save-flag t
      bookmark-set-fringe-mark t
      bookmark-menu-confirm-deletion t)
#+END_SRC
* imenu-list
  Sidebar displaying the current buffer's structure via imenu. Shows functions, classes, methods, and other symbols in a dedicated sidebar window, providing an IDE-like code outline view. Toggle with C-' (imenu-list-smart-toggle), and the window automatically focuses after activation for quick navigation. The sidebar updates as you switch buffers, always showing the structure of the active file. Particularly useful for navigating large code files or understanding unfamiliar codebases. See https://github.com/bmag/imenu-list for full documentation.

#+BEGIN_SRC emacs-lisp
  (use-package imenu-list)
  (global-set-key (kbd "C-'") #'imenu-list-smart-toggle)
  (setq imenu-list-focus-after-activation t)
#+END_SRC

* Lua
  Lua programming language support with syntax highlighting, indentation, and basic editing features. Useful for working with Lua scripts, Neovim configuration files, or any project that uses Lua for scripting or configuration. Provides a foundation for Lua development within Emacs.

#+BEGIN_SRC emacs-lisp
    (use-package lua-mode)
#+END_SRC
* Startup Profiling
  Performance analysis tool for identifying slow Emacs startup. ESUP (Emacs Start Up Profiler) measures how long each part of your configuration takes to load, helping identify bottlenecks and optimize startup time. Run M-x esup to profile the init process and see a detailed breakdown of where time is spent. Useful for maintaining fast startup times as your configuration grows.

#+BEGIN_SRC emacs-lisp
  (use-package esup
    :commands esup)
#+END_SRC
